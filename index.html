<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rialo Runner — EXTREME Spawn Test</title>
<style>
  :root { color-scheme: light dark; }
  * { box-sizing: border-box; }
  body { margin:0; min-height:100svh; display:grid; place-items:center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; background:#0b0f14; }
  .wrap { display:grid; gap:10px; place-items:center; }
  canvas { background: linear-gradient(#0e1621,#0a1118 60%); border-radius:16px;
    box-shadow:0 16px 40px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
    image-rendering:pixelated; touch-action:manipulation; }
  .hud { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
  .btn { padding:8px 14px; border-radius:10px; border:0; cursor:pointer; font-weight:700;
    background:#14ff72; color:#05130a; box-shadow:0 6px 20px rgba(20,255,114,.3); }
  .hint { font-size:14px; opacity:.8; color:#b8c6d1 }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="720" height="360" aria-label="Rialo Runner — EXTREME"></canvas>
    <div class="hud">
      <button id="restart" class="btn">Restart (R)</button>
      <span class="hint">Space / ↑ / chạm để nhảy — chế độ EXTREME để test mật độ (P = Pause)</span>
    </div>
  </div>

<script>
(() => {
/* ================= EXTREME SPAWN TEST =================
   Mục tiêu: chắc chắn bạn thấy CHƯỚNG NGẠI VẬT NHIỀU HẲN.
   - Spawn mỗi 18 khung hình + có khả năng spawn lần 2 cùng tick (90%).
   - Cụm 2–5 vật, khoảng cách ngắn.
   - Trần on-screen cao (40).
   - HUD hiển thị: obs=<số lượng> để bạn quan sát trực tiếp.
   ===================================================== */

  // --- LOGO ---
  const LOGO_SRC = "qbjSWMDP_400x400.jpg"; // <--- ĐỔI theo tên logo của bạn

  // --- EXTREME parameters (rất dày) ---
  const BASE_SPAWN_EVERY = 18;   // spawn mỗi 18 khung hình
  const MIN_SPAWN_EVERY  = 12;   // không giảm xuống dưới 12
  const EXTRA_SPAWN_PROB = 0.90; // 90% cơ hội spawn lần 2 trong cùng tick

  const CLUSTER_CHANCE   = 0.90; // 90% spawn theo cụm
  const CLUSTER_MAX      = 5;    // tối đa 5 vật trong cụm
  const MIN_GAP          = 24;   // khoảng cách tối thiểu trong cụm (px)
  const EXTRA_RAND_GAP   = 24;   // random thêm (px)

  const MAX_OBS_ONSCREEN = 40;   // trần số vật trên màn hình

  // --- Canvas ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fitCanvas() {
    const dpr = Math.max(1, Math.floor((window.devicePixelRatio || 1)));
    const w = canvas.width, h = canvas.height;
    canvas.width = w * dpr; canvas.height = h * dpr;
    canvas.style.width = w + "px"; canvas.style.height = h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas(); addEventListener('resize', fitCanvas);

  const W = 720, H = 360, groundY = H - 64;

  // --- Assets: Logo ---
  const logoImg = new Image(); let logoReady = false;
  logoImg.onload = () => logoReady = true;
  logoImg.onerror = () => console.warn("Không tìm thấy file logo:", LOGO_SRC);
  logoImg.src = LOGO_SRC;

  // --- World ---
  let speed = 5, spawnEvery = BASE_SPAWN_EVERY, frame = 0;
  const stars = Array.from({length:60}, () => ({
    x: Math.random()*W, y: Math.random()*groundY*0.9, r: Math.random()*1.5+.5, v: Math.random()*0.4+0.2
  }));
  const hills = [{x:0,h:70,v:1.2}, {x:W,h:70,v:1.2}];

  // --- Player: logo tròn xoay ---
  const player = { x:90, y:groundY-40, w:40, h:40, vy:0, onGround:true, anim:0 };
  const gravity = 0.7, jumpV = -12;

  // --- Obstacles & Items ---
  let obs = [];
  function spawnObstacle() {
    function one(atX){
      const t = Math.random();
      if (t < 0.5) obs.push({ x:atX, y:groundY-30, w:22, h:30, type:"cactus" });
      else if (t < 0.8) obs.push({ x:atX, y:groundY-50, w:24, h:50, type:"tall" });
      else obs.push({ x:atX, y:groundY-20, w:48, h:20, type:"wide" });
    }
    const startX = W + 20;
    if (Math.random() < CLUSTER_CHANCE) {
      const n = 2 + Math.floor(Math.random()*(CLUSTER_MAX-1)); // 2..CLUSTER_MAX
      let x = startX;
      for (let i=0;i<n;i++){
        one(x);
        x += MIN_GAP + Math.random()*EXTRA_RAND_GAP;
        if (obs.length >= MAX_OBS_ONSCREEN) break;
      }
    } else one(startX);
  }

  let items = [], ITEM_BASE_GAP = 160, ITEM_SPEED_MULT = 1.0, nextItemAt = 60;
  function spawnItem(){
    const size = 26 + Math.random()*8, r=size/2;
    const y = (groundY-110) + Math.random()*50;
    items.push({ x:W+30, y, r, ang:Math.random()*Math.PI*2, spin:0.035+Math.random()*0.03, trail:[] });
    nextItemAt = frame + Math.floor(ITEM_BASE_GAP + Math.random()*60);
  }

  // --- Effects ---
  const particles = [], floats = [];
  function burst(x,y,c="rgba(20,255,114,"){ for(let i=0;i<16;i++){ const a=Math.random()*Math.PI*2, sp=1.5+Math.random()*2.5;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0,maxLife:28,color:c}); } }
  function addFloat(x,y,text="+10"){ floats.push({x,y,text,life:0,maxLife:40}); }

  // --- State ---
  let running = true, started = false, paused = false;
  let score = 0, best = Number(localStorage.getItem('rialo_runner_best')||0), flash=0, logoSpin=0;

  // --- Input ---
  function jump(){ if(!running){reset();return;} if(paused) return; started=true;
    if(player.onGround){ player.vy=jumpV; player.onGround=false; } }
  addEventListener('keydown',e=>{
    if (["Space","ArrowUp","KeyW"].includes(e.code)) { e.preventDefault(); jump(); }
    if (e.key.toLowerCase()==='r') reset();
    if (e.key.toLowerCase()==='p') paused=!paused;
  }, {passive:false});
  document.getElementById('restart').addEventListener('click', reset);
  document.getElementById('game').addEventListener('pointerdown', ev=>{ev.preventDefault(); jump();},{passive:false});

  function reset(){
    obs=[]; items=[]; particles.length=0; floats.length=0;
    speed=5; spawnEvery=BASE_SPAWN_EVERY; frame=0; nextItemAt=60;
    Object.assign(player,{x:90,y:groundY-40,w:40,h:40,vy:0,onGround:true,anim:0});
    score=0; running=true; started=false; flash=0; paused=false;
  }

  // --- Utils ---
  function overlapCircleRect(cx,cy,r,rx,ry,rw,rh){
    const nx=Math.max(rx,Math.min(cx,rx+rw)), ny=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-nx, dy=cy-ny; return (dx*dx+dy*dy) < r*r;
  }
  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  // --- Update ---
  function update(){
    if (paused) return;
    frame++;

    // Parallax
    for(const s of stars){ s.x-=s.v; if(s.x<-2){ s.x=W+Math.random()*40; s.y=Math.random()*groundY*0.9; } }
    for(const h of hills){ h.x-=h.v; if(h.x<-W) h.x+=2*W; }

    // SPAWN EXTREME
    if (started && frame % spawnEvery === 0 && obs.length < MAX_OBS_ONSCREEN) {
      spawnObstacle();
      if (Math.random() < EXTRA_SPAWN_PROB && obs.length < MAX_OBS_ONSCREEN) spawnObstacle();
    }

    // Items
    if (started && frame >= nextItemAt) spawnItem();

    // Move
    for (let i=obs.length-1;i>=0;i--){ const o=obs[i]; o.x-=speed; if(o.x+o.w<-20) obs.splice(i,1); }
    for (let i=items.length-1;i>=0;i--){ const it=items[i]; it.x-=speed*ITEM_SPEED_MULT; it.ang+=it.spin;
      it.trail.push({x:it.x,y:it.y}); if(it.trail.length>12) it.trail.shift(); if(it.x+it.r<-10) items.splice(i,1); }

    // Player physics
    if (started){
      player.vy += gravity; player.y += player.vy;
      if (player.y + player.h >= groundY){ player.y=groundY-player.h; player.vy=0; player.onGround=true; } else player.onGround=false;
      player.anim += 0.2 + speed*0.02;
    }

    // Score & difficulty (giảm spawnEvery dần nhưng không dưới MIN_SPAWN_EVERY)
    if (started && running){
      score += 0.1;
      if (Math.floor(score) % 50 === 0 && frame % 15 === 0){
        speed = Math.min(12, speed + 0.02);
        spawnEvery = Math.max(MIN_SPAWN_EVERY, spawnEvery - 0.12);
      }
    }

    // Collisions
    const cx=player.x+player.w/2, cy=player.y+player.h/2, r=Math.min(player.w,player.h)/2-3;
    for (const o of obs){
      if (overlapCircleRect(cx,cy,r,o.x,o.y,o.w,o.h)){
        running=false; best=Math.max(best,Math.floor(score)); localStorage.setItem('rialo_runner_best',best); flash=14; break;
      }
    }
    for (let i=items.length-1;i>=0;i--){
      const it=items[i];
      if (dist2(cx,cy,it.x,it.y) < (r+it.r)*(r+it.r)){
        items.splice(i,1); score+=10; burst(it.x,it.y,"rgba(20,255,114,"); addFloat(it.x,it.y-10,"+10");
      }
    }

    // Effects
    for (let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.04; p.life++; if(p.life>p.maxLife) particles.splice(i,1); }
    for (let i=floats.length-1;i>=0;i--){ const f=floats[i]; f.y-=0.6; f.life++; if(f.life>f.maxLife) floats.splice(i,1); }

    if (flash>0) flash--; logoSpin += 0.01 + speed*0.002;
  }

  // --- Draw ---
  function drawGround(){
    ctx.globalAlpha=0.9; ctx.fillStyle="#cfe8ff";
    for(const s of stars){ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); }
    ctx.globalAlpha=1;
    ctx.fillStyle="#12202b";
    for(const h of hills){
      ctx.beginPath(); ctx.moveTo(h.x,groundY);
      ctx.quadraticCurveTo(h.x+W*0.25, groundY-h.h, h.x+W*0.5, groundY);
      ctx.quadraticCurveTo(h.x+W*0.75, groundY-h.h*1.2, h.x+W, groundY);
      ctx.lineTo(h.x+W,H); ctx.lineTo(h.x,H); ctx.closePath(); ctx.fill();
    }
    ctx.fillStyle="#0f1a22"; ctx.fillRect(0,groundY,W,H-groundY);
    ctx.strokeStyle="#163142"; ctx.lineWidth=2;
    for(let x=0;x<W;x+=28){ ctx.beginPath(); ctx.moveTo(x-(frame%speed), groundY+12); ctx.lineTo(x+14-(frame%speed), groundY+12); ctx.stroke(); }
  }

  function drawObstacle(o){
    ctx.save(); ctx.shadowColor="#14ff72"; ctx.shadowBlur=8; ctx.fillStyle="#14ff72";
    ctx.fillRect(o.x,o.y,o.w,o.h); ctx.shadowBlur=0; ctx.fillStyle="rgba(255,255,255,.15)";
    ctx.fillRect(o.x,o.y,o.w,4); ctx.restore();
  }

  function drawItem(it){
    for(let i=0;i<it.trail.length;i++){ const t=it.trail[i], a=i/it.trail.length;
      ctx.save(); ctx.globalAlpha=a*0.35; ctx.beginPath(); ctx.arc(t.x,t.y,it.r*(0.8+0.2*a),0,Math.PI*2);
      ctx.fillStyle="#14ff72"; ctx.fill(); ctx.restore();
    }
    ctx.save(); ctx.translate(it.x,it.y); ctx.rotate(it.ang);
    ctx.beginPath(); ctx.arc(0,0,it.r+6,0,Math.PI*2); ctx.strokeStyle="rgba(20,255,114,.35)"; ctx.lineWidth=4; ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,it.r,0,Math.PI*2); ctx.closePath(); ctx.save(); ctx.clip();
    if(logoReady){ const s=it.r*2; ctx.drawImage(logoImg,-s/2,-s/2,s,s); } else { ctx.fillStyle="#0ff078"; ctx.fillRect(-it.r,-it.r,it.r*2,it.r*2); }
    ctx.restore(); ctx.beginPath(); ctx.arc(0,0,it.r,0,Math.PI*2); ctx.strokeStyle="rgba(0,0,0,.35)"; ctx.lineWidth=2; ctx.stroke();
    ctx.restore();
  }

  function drawPlayer(){
    const {x,y,w,h}=player, cx=x+w/2, cy=y+h/2, r=Math.min(w,h)/2;
    ctx.fillStyle="rgba(0,0,0,.25)"; ctx.beginPath(); ctx.ellipse(cx+4,cy+6,r*1.0,r*0.5,0,0,Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(logoSpin*0.6);
    ctx.beginPath(); ctx.arc(0,0,r+8,0,Math.PI*2); ctx.strokeStyle="rgba(20,255,114,.35)"; ctx.lineWidth=6; ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.closePath(); ctx.save(); ctx.clip();
    if(logoReady){ const s=r*2; ctx.drawImage(logoImg,-s/2,-s/2,s,s); } else { ctx.fillStyle="#0ff078"; ctx.fillRect(-r,-r,2*r,2*r); }
    ctx.restore(); ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.strokeStyle="rgba(0,0,0,.35)"; ctx.lineWidth=2; ctx.stroke();
    ctx.restore();
  }

  function drawHUD(){
    const s=Math.floor(score);
    ctx.fillStyle="#cfe8ff"; ctx.font="bold 20px ui-sans-serif, system-ui";
    const text = `Score: ${s}   Best: ${best}   obs:${obs.length}`;
    const m = ctx.measureText(text);
    ctx.fillText(text, W - m.width - 80, 40);
  }

  function drawRialoTitle(){
    ctx.shadowColor="#14ff72"; ctx.shadowBlur=14; ctx.fillStyle="#14ff72";
    ctx.font="800 28px ui-sans-serif, system-ui"; ctx.fillText("Rialo",20,40); ctx.shadowBlur=0;
    ctx.fillStyle="#9cc9b0"; ctx.font="12px ui-sans-serif, system-ui";
    ctx.fillText("Runner • EXTREME spawn test",22,58);
  }

  function drawLogoWatermark(){
    if(!SHOW_WATERMARK) return;
    const cx=W-64, cy=58, r=26; ctx.save(); ctx.translate(cx,cy); ctx.rotate(logoSpin*0.25);
    if(logoReady){ const s=44; ctx.beginPath(); ctx.arc(0,0,r+10,0,Math.PI*2);
      ctx.strokeStyle="rgba(20,255,114,.25)"; ctx.lineWidth=6; ctx.stroke(); ctx.drawImage(logoImg,-s/2,-s/2,s,s);
    } else { ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fillStyle="rgba(20,255,114,.25)"; ctx.fill(); }
    ctx.restore();
  }

  function drawStartOrGameOver(){
    if (!started && running){ ctx.fillStyle="#b8c6d1"; ctx.font="bold 22px ui-sans-serif, system-ui";
      ctx.fillText("Nhấn Space / ↑ / Chạm để bắt đầu (P = Pause)", W/2 - 260, H/2 - 10); }
    if (!running){ if (flash>0){ ctx.fillStyle="rgba(255,40,40,.25)"; ctx.fillRect(0,0,W,H); }
      ctx.fillStyle="#fff"; ctx.font="800 36px ui-sans-serif, system-ui"; ctx.fillText("GAME OVER", W/2 - 110, H/2 - 8);
      ctx.font="16px ui-sans-serif, system-ui"; ctx.fillStyle="#b8c6d1"; ctx.fillText("Nhấn R để chơi lại", W/2 - 80, H/2 + 18); }
    if (paused && running){ ctx.fillStyle="rgba(0,0,0,.35)"; ctx.fillRect(0,0,W,H);
      ctx.fillStyle="#fff"; ctx.font="800 28px ui-sans-serif, system-ui"; ctx.fillText("PAUSED (nhấn P để tiếp tục)", W/2 - 160, H/2); }
  }

  // --- Loop ---
  function render(){
    if (running) update();
    ctx.clearRect(0,0,W,H);
    drawGround(); obs.forEach(drawObstacle); items.forEach(drawItem);
    drawPlayer(); drawRialoTitle(); drawHUD(); drawLogoWatermark(); drawStartOrGameOver();
    requestAnimationFrame(render);
  }
  render();
})();
</script>
</body>
</html>
