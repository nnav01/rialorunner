<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rialo Runner — Logo Player + Items + Watermark</title>
<style>
  :root { color-scheme: light dark; }
  * { box-sizing: border-box; }
  body {
    margin:0; min-height:100svh; display:grid; place-items:center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    background: #0b0f14;
  }
  .wrap { display:grid; gap:10px; place-items:center; }
  canvas {
    background: linear-gradient(#0e1621, #0a1118 60%);
    border-radius: 16px;
    box-shadow: 0 16px 40px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
    image-rendering: pixelated;
    touch-action: manipulation;
  }
  .hud { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
  .btn {
    padding:8px 14px; border-radius:10px; border:0; cursor:pointer; font-weight:700;
    background:#14ff72; color:#05130a; box-shadow: 0 6px 20px rgba(20,255,114,.3);
  }
  .hint { font-size:14px; opacity:.8; color:#b8c6d1 }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="720" height="360" aria-label="Rialo Runner — Logo Player + Items + Watermark"></canvas>
    <div class="hud">
      <button id="restart" class="btn">Restart (R)</button>
      <span class="hint">Space / ↑ / chạm để nhảy — né block, nhặt logo +10 điểm!</span>
    </div>
  </div>

<script>
(() => {
  // ====== Cấu hình nhanh ======
  const LOGO_SRC = "rialo-logo.png";   // ĐỔI đúng tên/đuôi file logo của bạn (.jpg/.png/.webp)
  const SHOW_WATERMARK = true;          // watermark góc phải

  // Item (token logo) settings
  const ITEM_ENABLED = true;
  const ITEM_BASE_GAP = 180;   // khoảng khung hình giữa 2 item
  const ITEM_SPEED_MULT = 1.0; // item chạy cùng tốc độ nền

  // ====== Canvas setup (Retina crisp) ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fitCanvas() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = canvas.width, cssH = canvas.height;
    canvas.width = cssW * dpr; canvas.height = cssH * dpr;
    canvas.style.width = cssW + "px"; canvas.style.height = cssH + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  const W = 720, H = 360;

  // ====== Assets: Logo (dùng chung cho player + item + watermark) ======
  const logoImg = new Image();
  let logoReady = false;
  logoImg.onload = () => logoReady = true;
  logoImg.onerror = () => console.warn("Không tìm thấy file logo:", LOGO_SRC);
  logoImg.src = LOGO_SRC; // đặt cùng thư mục với index.html

  // ====== World constants ======
  const groundY = H - 64;
  let speed = 5;            // tốc độ chạy
  let spawnEvery = 80;      // khung hình giữa chướng ngại
  let frame = 0;

  // Parallax layers
  const stars = Array.from({length: 60}, () => ({
    x: Math.random()*W, y: Math.random()*groundY*0.9, r: Math.random()*1.5 + .5, v: Math.random()*0.4 + 0.2
  }));
  const hills = [
    { x:0, h: 70, v: 1.2 },
    { x:W, h: 70, v: 1.2 },
  ];

  // ====== Player = Logo tròn xoay ======
  const player = {
    x: 90, y: groundY - 40, w: 40, h: 40,
    vy: 0, onGround: true, anim: 0
  };
  const gravity = 0.7;
  const jumpV = -12;

  // ====== Obstacles ======
  let obs = [];
  function spawnObstacle() {
    const t = Math.random();
    if (t < 0.5) {             // cactus block
      obs.push({ x: W + 20, y: groundY - 30, w: 22, h: 30, type:"cactus" });
    } else if (t < 0.8) {      // tall
      obs.push({ x: W + 20, y: groundY - 50, w: 24, h: 50, type:"tall" });
    } else {                    // wide low
      obs.push({ x: W + 20, y: groundY - 20, w: 48, h: 20, type:"wide" });
    }
  }

  // ====== Items (token logo để nhặt) ======
  let items = [];
  let nextItemAt = 90; // khi nào spawn item tiếp theo (theo frame)

  function spawnItem() {
    const size = 26 + Math.random()*8; // đường kính
    const r = size/2;
    // Vị trí Y: bay lơ lửng trong khoảng từ mặt đất-100 lên đến giữa trời
    const minY = groundY - 110;
    const maxY = groundY - 60;
    const y = Math.random()*(maxY - minY) + minY;
    items.push({
      x: W + 30, y: y, r: r, ang: Math.random()*Math.PI*2, spin: 0.03 + Math.random()*0.03,
      trail: [] // trail sẽ chứa lịch sử điểm để vẽ vệt sáng
    });
    // Random khoảng cách cho lần sau
    nextItemAt = frame + Math.floor(ITEM_BASE_GAP + Math.random()*80);
  }

  // ====== Particles & Floating texts ======
  const particles = []; // {x,y,vx,vy,life,maxLife,color}
  const floats = [];    // {x,y,text,life,maxLife}

  function burst(x,y,color="rgba(20,255,114,") {
    for (let i=0;i<16;i++){
      const a = Math.random()*Math.PI*2;
      const sp= 1.5 + Math.random()*2.5;
      particles.push({
        x,y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life:0, maxLife:28,
        color
      });
    }
  }
  function addFloat(x,y,text="+10"){
    floats.push({x,y, text, life:0, maxLife:40});
  }

  // ====== Game state ======
  let running = true, started = false;
  let score = 0, best = Number(localStorage.getItem('rialo_runner_best') || 0);
  let flash = 0; // hit flash timer
  let logoSpin = 0; // quay logo

  // ====== Input ======
  function jump() {
    if (!running) { reset(); return; }
    started = true;
    if (player.onGround) {
      player.vy = jumpV;
      player.onGround = false;
    }
  }
  addEventListener('keydown', e => {
    if (["Space","ArrowUp","KeyW"].includes(e.code)) { e.preventDefault(); jump(); }
    if (e.key.toLowerCase() === 'r') reset();
  }, { passive:false });
  canvas.addEventListener('pointerdown', jump);
  document.getElementById('restart').addEventListener('click', reset);

  function reset() {
    obs = []; items = []; particles.length = 0; floats.length = 0;
    speed = 5; spawnEvery = 80; frame = 0; nextItemAt = 90;
    player.x = 90; player.y = groundY - player.h; player.vy = 0; player.onGround = true; player.anim = 0;
    score = 0; running = true; started = false; flash = 0;
  }

  // ====== Utils ======
  function overlapCircleRect(cx, cy, r, rx, ry, rw, rh) {
    const nx = Math.max(rx, Math.min(cx, rx + rw));
    const ny = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) < (r*r);
  }
  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  // ====== Update ======
  function update() {
    frame++;

    // Parallax
    for (const s of stars) {
      s.x -= s.v;
      if (s.x < -2) { s.x = W + Math.random()*40; s.y = Math.random()*groundY*0.9; }
    }
    hills.forEach(h => { h.x -= h.v; if (h.x < -W) h.x += 2*W; });

    // Spawn obstacles
    if (started && frame % spawnEvery === 0) spawnObstacle();

    // Spawn items
    if (ITEM_ENABLED && started && frame >= nextItemAt) spawnItem();

    // Move obstacles
    for (let i = obs.length-1; i >= 0; i--) {
      const o = obs[i];
      o.x -= speed;
      if (o.x + o.w < -20) obs.splice(i,1);
    }

    // Move items (cùng tốc độ nền, có vệt trail)
    for (let i = items.length-1; i >= 0; i--) {
      const it = items[i];
      it.x -= speed * ITEM_SPEED_MULT;
      it.ang += it.spin;
      // lưu trail (tối đa 12 điểm)
      it.trail.push({x: it.x, y: it.y});
      if (it.trail.length > 12) it.trail.shift();
      // loại item ra khi ra màn hình
      if (it.x + it.r < -10) items.splice(i,1);
    }

    // Player physics
    if (started) {
      player.vy += gravity;
      player.y += player.vy;
      if (player.y + player.h >= groundY) {
        player.y = groundY - player.h;
        player.vy = 0;
        player.onGround = true;
      }
      player.anim += 0.2 + speed*0.02;
    }

    // Score & difficulty (cộng dần theo thời gian)
    if (started && running) {
      score += 0.1;
      if (Math.floor(score) % 50 === 0 && frame % 15 === 0) {
        speed = Math.min(12, speed + 0.02);
        spawnEvery = Math.max(52, spawnEvery - 0.02);
      }
    }

    // Collisions với obstacles (circle hitbox cho player)
    const cx = player.x + player.w/2;
    const cy = player.y + player.h/2;
    const r  = Math.min(player.w, player.h)/2 - 3;

    for (const o of obs) {
      if (overlapCircleRect(cx, cy, r, o.x, o.y, o.w, o.h)) {
        running = false; best = Math.max(best, Math.floor(score));
        localStorage.setItem('rialo_runner_best', best);
        flash = 14;
        break;
      }
    }

    // Collisions với items (circle-circle)
    for (let i = items.length-1; i >= 0; i--) {
      const it = items[i];
      if (dist2(cx,cy,it.x,it.y) < (r+it.r)*(r+it.r)) {
        // Thu thập
        items.splice(i,1);
        score += 10;
        burst(it.x, it.y, "rgba(20,255,114,");
        addFloat(it.x, it.y - 10, "+10");
      }
    }

    // Update particles
    for (let i = particles.length-1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.04; // gravity nhẹ
      p.life++;
      if (p.life > p.maxLife) particles.splice(i,1);
    }

    // Update floating texts
    for (let i = floats.length-1; i >= 0; i--) {
      const f = floats[i];
      f.y -= 0.6;
      f.life++;
      if (f.life > f.maxLife) floats.splice(i,1);
    }

    if (flash > 0) flash--;
    logoSpin += 0.01 + speed*0.002;
  }

  // ====== Draw helpers ======
  function drawGround() {
    // Stars
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#cfe8ff";
    for (const s of stars) {
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Hills
    ctx.fillStyle = "#12202b";
    hills.forEach(h => {
      ctx.beginPath();
      ctx.moveTo(h.x, groundY);
      ctx.quadraticCurveTo(h.x+W*0.25, groundY - h.h, h.x+W*0.5, groundY);
      ctx.quadraticCurveTo(h.x+W*0.75, groundY - h.h*1.2, h.x+W, groundY);
      ctx.lineTo(h.x+W, H); ctx.lineTo(h.x, H); ctx.closePath(); ctx.fill();
    });

    // Ground strip + lane
    ctx.fillStyle = "#0f1a22";
    ctx.fillRect(0, groundY, W, H - groundY);
    ctx.strokeStyle = "#163142";
    ctx.lineWidth = 2;
    for (let x=0; x<W; x+=28) {
      ctx.beginPath(); ctx.moveTo(x - (frame%speed), groundY+12); ctx.lineTo(x+14 - (frame%speed), groundY+12); ctx.stroke();
    }
  }

  function drawObstacle(o) {
    ctx.save();
    ctx.shadowColor = "#14ff72"; ctx.shadowBlur = 8;
    ctx.fillStyle = "#14ff72";
    ctx.fillRect(o.x, o.y, o.w, o.h);
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(255,255,255,.15)";
    ctx.fillRect(o.x, o.y, o.w, 4);
    ctx.restore();
  }

  function drawItem(it) {
    // vệt trail
    for (let i=0; i<it.trail.length; i++) {
      const t = it.trail[i];
      const alpha = i / it.trail.length;
      ctx.save();
      ctx.globalAlpha = alpha * 0.35;
      ctx.beginPath(); ctx.arc(t.x, t.y, it.r * (0.8 + 0.2*alpha), 0, Math.PI*2); ctx.fillStyle = "#14ff72"; ctx.fill();
      ctx.restore();
    }
    // token logo tròn xoay
    ctx.save();
    ctx.translate(it.x, it.y);
    ctx.rotate(it.ang);
    // viền phát sáng
    ctx.beginPath();
    ctx.arc(0, 0, it.r+6, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(20,255,114,.35)";
    ctx.lineWidth = 4;
    ctx.stroke();

    // clip tròn
    ctx.beginPath(); ctx.arc(0, 0, it.r, 0, Math.PI*2); ctx.closePath();
    ctx.save(); ctx.clip();

    if (logoReady) {
      const s = it.r*2;
      ctx.drawImage(logoImg, -s/2, -s/2, s, s);
    } else {
      ctx.fillStyle = "#0ff078";
      ctx.fillRect(-it.r, -it.r, it.r*2, it.r*2);
    }
    ctx.restore();

    // viền trong
    ctx.beginPath(); ctx.arc(0,0,it.r,0,Math.PI*2);
    ctx.strokeStyle = "rgba(0,0,0,.35)"; ctx.lineWidth = 2; ctx.stroke();

    ctx.restore();
  }

  // ====== PLAYER: Logo tròn xoay ======
  function drawPlayer() {
    const { x, y, w, h } = player;
    const cx = x + w/2, cy = y + h/2;
    const r = Math.min(w, h)/2;

    // bóng
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.beginPath(); ctx.ellipse(cx+4, cy+6, r*1.0, r*0.5, 0, 0, Math.PI*2); ctx.fill();

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(logoSpin * 0.6);

    // glow
    ctx.beginPath();
    ctx.arc(0, 0, r + 8, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(20,255,114,.35)";
    ctx.lineWidth = 6;
    ctx.stroke();

    // clip tròn
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.closePath();
    ctx.save(); ctx.clip();

    if (logoReady) {
      const s = r*2;
      ctx.drawImage(logoImg, -s/2, -s/2, s, s);
    } else {
      ctx.fillStyle = "#0ff078";
      ctx.fillRect(-r, -r, 2*r, 2*r);
    }
    ctx.restore();

    // viền trong
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  function drawRialoTitle() {
    const title = "Rialo";
    const x = 20, y = 40;
    ctx.shadowColor = "#14ff72"; ctx.shadowBlur = 14;
    ctx.fillStyle = "#14ff72";
    ctx.font = "800 28px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title, x, y);
    ctx.shadowBlur = 0;

    ctx.fillStyle = "#9cc9b0";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.fillText("Runner • Avoid blocks • Collect logos", x+2, y+18);
  }

  function drawHUD() {
    const s = Math.floor(score);
    ctx.fillStyle = "#cfe8ff";
    ctx.font = "bold 20px ui-sans-serif, system-ui";
    const text = `Score: ${s}   Best: ${best}`;
    const m = ctx.measureText(text);
    ctx.fillText(text, W - m.width - 80, 40);
  }

  // ===== Watermark góc phải (logo ở trên) =====
  function drawLogoWatermark() {
    if (!SHOW_WATERMARK) return;
    const cx = W - 64, cy = 58, r = 26;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(logoSpin*0.25);
    if (logoReady) {
      const s = 44;
      // Vòng glow
      ctx.beginPath(); ctx.arc(0,0,r+10,0,Math.PI*2);
      ctx.strokeStyle = "rgba(20,255,114,.25)"; ctx.lineWidth = 6; ctx.stroke();
      // Logo
      ctx.drawImage(logoImg, -s/2, -s/2, s, s);
    } else {
      // Placeholder hình tròn
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fillStyle = "rgba(20,255,114,.25)"; ctx.fill();
      ctx.beginPath(); ctx.arc(0,0,r-8,0,Math.PI*2);
      ctx.strokeStyle = "rgba(20,255,114,.5)"; ctx.lineWidth = 3; ctx.stroke();
    }
    ctx.restore();
  }

  function drawStartOrGameOver() {
    if (!started && running) {
      ctx.fillStyle = "#b8c6d1";
      ctx.font = "bold 22px ui-sans-serif, system-ui";
      ctx.fillText("Nhấn Space / ↑ / Chạm để bắt đầu", W/2 - 210, H/2 - 10);
    }
    if (!running) {
      if (flash > 0) { ctx.fillStyle = "rgba(255,40,40,.25)"; ctx.fillRect(0,0,W,H); }
      ctx.fillStyle = "#ffffff";
      ctx.font = "800 36px ui-sans-serif, system-ui";
      ctx.fillText("GAME OVER", W/2 - 110, H/2 - 8);
      ctx.font = "16px ui-sans-serif, system-ui";
      ctx.fillStyle = "#b8c6d1";
      ctx.fillText("Nhấn R để chơi lại", W/2 - 80, H/2 + 18);
    }
  }

  // Draw particles & floats
  function drawEffects() {
    // particles
    for (const p of particles) {
      const t = 1 - p.life/p.maxLife;
      ctx.fillStyle = p.color + (0.15 + 0.55*t) + ")";
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    // floating texts
    for (const f of floats) {
      const t = 1 - f.life/f.maxLife;
      ctx.globalAlpha = 0.2 + 0.8*t;
      ctx.fillStyle = "#14ff72";
      ctx.font = "bold 18px ui-sans-serif, system-ui";
      ctx.fillText(f.text, f.x - 14, f.y);
      ctx.globalAlpha = 1;
    }
  }

  // ====== Main Loop ======
  function render() {
    if (running) update();

    ctx.clearRect(0,0,W,H);
    drawGround();
    obs.forEach(drawObstacle);
    items.forEach(drawItem);
    drawPlayer();
    drawEffects();
    drawRialoTitle();
    drawHUD();
    drawLogoWatermark();   // <- watermark dùng chung logo ở trên
    drawStartOrGameOver();

    requestAnimationFrame(render);
  }
  render();
})();
</script>
</body>
</html>
